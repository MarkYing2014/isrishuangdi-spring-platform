/**
 * Shock Spring Module - Physics Analysis
 * 
 * CORE LOGIC:
 * 1. computeKxCurve: Generates Non-Linear Stiffness Profile via Segmented Aggregation
 * 2. solveForceAtX: Integral-based force calculation (P = integral k dx)
 * 3. estimateFatigue: Modified Goodman criterion
 */

import { linearStiffness, correctedShearStress } from "./math";
import type {
    ShockSpringInput,
    ShockSpringDerived,
    ShockSpringResult,
    KxPoint,
    FatigueResult
} from "./types";
import { generateCenterline } from "./model";

// ============================================================================
// 1. Core Physics Pipeline
// ============================================================================

export function runShockSpringAnalysis(input: ShockSpringInput): ShockSpringResult {
    // A. Generate Geometry (Centerline, Frames, Segments)
    const derived = generateCenterline(input);

    // B. Compute K(x) Curve (Non-Linear Stiffness)
    //    Using Segmented Aggregation for numerical stability
    const kxCurve = computeKxCurve(input, derived);

    // C. Energy Curve (Integral of Force)
    const energyCurve = computeEnergyCurve(kxCurve);

    // D. Solve Operating Points
    const preload = solveOperatingPoint(kxCurve, input.installation.preloadedLength ?? derived.freeLength, input.loadCase.rideDeflection ?? 0, derived.freeLength, "Preload");

    // Determine Ride/Bump based on input type (Height vs Deflection)
    // Priority: Deflection > Height

    // Ride
    let rideDeflection = input.loadCase.rideDeflection ?? 0;
    if (input.loadCase.rideDeflection == null && input.loadCase.rideHeight != null) {
        rideDeflection = derived.freeLength - input.loadCase.rideHeight;
    }
    const ride = solveOperatingPoint(kxCurve, undefined, rideDeflection, derived.freeLength, "Ride");

    // Bump
    let bumpDeflection = input.loadCase.bumpDeflection ?? 0;
    if (input.loadCase.bumpDeflection == null && input.loadCase.bumpHeight != null) {
        bumpDeflection = derived.freeLength - input.loadCase.bumpHeight;
    }
    const bump = solveOperatingPoint(kxCurve, undefined, bumpDeflection, derived.freeLength, "Bump");

    // E. Fatigue Analysis
    const fatigue = estimateFatigue(ride.stress, bump.stress, input.material.tensileStrength);

    return {
        isValid: true,
        errors: [],
        derived,
        kxCurve,
        energyCurve,
        preload,
        ride: { ...ride, sf: fatigue.safetyFactor }, // Rough SF linkage
        bump: { ...bump, sf: input.material.tensileStrength * 0.577 / bump.stress }, // Yield SF
        fatigue,
        designRules: [] // To be filled by designRules.ts
    };
}


// ============================================================================
// 2. Non-Linear Stiffness Calculation (Segmented Aggregation)
// ============================================================================

/**
 * Computes the k(x) curve by simulating progressive coil binding.
 * 
 * STRATEGY:
 * 1. Group point-wise data into "Segments" (fraction of a turn, e.g. 1/4 turn).
 * 2. Calculate average gap for each segment.
 * 3. Sort segments by gap size.
 * 4. Progressively "close" segments as deflection x increases.
 * 5. Update Active Coils (Na) -> Calculate k_instant = G*d^4 / 8*D^3*Na_eff
 */
export function computeKxCurve(input: ShockSpringInput, derived: ShockSpringDerived): KxPoint[] {
    const { material } = input;
    const G = material.shearModulus;

    // 1. Aggregate Segments
    // derived.segments contains point-wise segments. 
    // We want to group them to ensure stability (prevent high freq jitter from single point closing).

    // Let's use the provided segments directly if they represent small enough chunks (generated by model.ts)
    // model.ts generates segments between every centerline point.
    // If samplesPerTurn = 60, each segment is 6deg. This is fine for resolution.
    // To ensure "Segmented Aggregation" stability as requested, we can use these micro-segments 
    // but ensure we smooth the transition.

    const rawSegments = derived.segments.map(s => ({
        ...s,
        // Calculate partial compliance C_i = 1/k_i for this segment
        // k_segment = G d^4 / 8 D^3 (d_n)
        // d_n = fraction of turn = (s.normEnd - s.normStart) * totalTurns
        // FIX: Must multiply by totalTurns because normEnd/Start are 0..1 globally.
        compliance: (8 * Math.pow(s.meanDia, 3) * (s.normEnd - s.normStart) * input.totalTurns) / (G * Math.pow(s.wireDia, 4)),
        isClosed: false
    }));

    // Sort compliant segments by gap size.
    // As we compress, segments with smallest gap close first.
    // We need to simulate the compression process.

    // This is a "contact mechanics" simulation.
    // Unlike linear algebra, here we have geometric nonlinearity.
    // We will step strain (deflection) and see what closes.

    // SIMPLIFIED ALGORITHM (Robust & Stable):
    // 1. Assume all segments active initially. Compute C_total_0 -> k_0.
    // 2. Determine "Deflection to Close" for each segment IF it were the only thing compressing? No.
    //    Deflection X is distributed among segments proportional to their compliance.
    //    delta_i = X * (C_i / C_total)
    //    Segment closes when delta_i >= gap_i
    //    Measurement: X_close_i = gap_i * (C_total / C_i)
    //    BUT: C_total changes as other segments close! This requires iterative solving.

    // ITERATIVE SOLVER:
    // We will generate the curve by incrementing X.

    const maxDeflection = derived.freeLength - derived.solidHeight;
    // Increased steps for better resolution and stability (GEN-2 Req)
    const steps = 100;
    const points: KxPoint[] = [];

    // Initial state
    let accumulatedForce = 0;

    for (let i = 0; i <= steps; i++) {
        const xTarget = (i / steps) * maxDeflection;

        // At this specific deflection xTarget, which coils are closed?
        // We iterate to find equilibrium.
        // Simple heuristic: 
        // 1. Guess distribution based on current active C_total.
        // 2. Check overlap.
        // 3. Close segments.
        // 4. Re-compute C_total.
        // 5. Repeat until stable.

        // Clone segments state for this step (simulation is stateless per step to avoid drift)
        const stepSegments = rawSegments.map(s => ({ ...s, currentGap: s.gap, closed: false }));

        let activeCompliance = 0;
        let iter = 0;
        let converged = false;

        // Initial Compliance
        activeCompliance = stepSegments.reduce((sum, s) => sum + s.compliance, 0);

        while (!converged && iter < 10) {
            // Distribute Deflection xTarget across ACTIVE segments
            // x_distributed = xTarget - (sum of gaps of closed segments? No)

            // Total compression = Sum(delta_i)
            // For open segments: delta_i = F * C_i
            // For closed segments: delta_i = gap_i (capped)

            // We need to find Force F needed to produce xTarget.
            // X_total = Sum_open(F * C_i) + Sum_closed(gap_i)
            // X_total - Sum_closed(gap_i) = F * Sum_open(C_i)
            // F = (X_total - Sum_closed(gap_i)) / Sum_open(C_i)

            // Calculate Sum_closed_gaps
            const sumClosedGaps = stepSegments.filter(s => s.closed).reduce((sum, s) => sum + s.gap, 0);

            // Check if we are "over compressed" (solid)
            if (activeCompliance < 1e-9) {
                // Fully solid
                break;
            }

            const F_estimate = (xTarget - sumClosedGaps) / activeCompliance;

            // Now check if any open segment violates gap constraint under this Force
            let newClosure = false;

            stepSegments.forEach(s => {
                if (!s.closed) {
                    const delta = F_estimate * s.compliance;
                    if (delta >= s.gap) {
                        s.closed = true;
                        newClosure = true;
                    }
                }
            });

            // Re-calc active compliance
            activeCompliance = stepSegments.filter(s => !s.closed).reduce((sum, s) => sum + s.compliance, 0);

            if (!newClosure) {
                converged = true;
                accumulatedForce = F_estimate;
            }
            iter++;
        }

        // Result for this step
        // k_instant = dF/dx ? No, k_instant = 1 / C_active
        const k_inst = activeCompliance > 1e-9 ? (1 / activeCompliance) : 1e6; // Cap stiffness

        // Effective Na = Sum of (normEnd - normStart)*totalTurns of active segments
        const activeTurns = stepSegments.filter(s => !s.closed).reduce((sum, s) => sum + (s.normEnd - s.normStart) * input.totalTurns, 0);

        // Max Stress
        // tau = Kw * 8FD / pi*d^3
        // We take max over all segments (since D and d vary locally)
        let maxStress = 0;
        stepSegments.forEach(s => {
            // Force is constant series F (accumulatedForce)
            const vals = correctedShearStress(accumulatedForce, s.meanDia, s.wireDia);
            if (vals > maxStress) maxStress = vals;
        });

        points.push({
            x: xTarget,
            k: k_inst,
            force: accumulatedForce, // This is P(x) derived from equilibrium
            activeCoils: activeTurns,
            stress: maxStress
        });
    }

    return points;
}


// ============================================================================
// 3. Energy Computation
// ============================================================================

function computeEnergyCurve(kxCurve: KxPoint[]): { x: number; joules: number }[] {
    const energy: { x: number; joules: number }[] = [];
    // E = integral F dx
    // Trapezoidal rule using the Force from kxCurve
    let currentJ = 0;

    if (kxCurve.length === 0) return [];

    energy.push({ x: kxCurve[0].x, joules: 0 });

    for (let i = 1; i < kxCurve.length; i++) {
        const p1 = kxCurve[i - 1];
        const p2 = kxCurve[i];
        const dx = (p2.x - p1.x) / 1000; // mm to m for Joules logic
        const F_avg = (p1.force + p2.force) / 2;

        const dJ = F_avg * dx; // N * m = Joules
        currentJ += dJ;

        energy.push({ x: p2.x, joules: currentJ });
    }
    return energy;
}


// ============================================================================
// 4. Operating Point Solver
// ============================================================================

function solveOperatingPoint(
    curve: KxPoint[],
    targetLength: number | undefined,
    targetDeflection: number,
    freeLength: number,
    name: string
): { x: number; force: number; stress: number; k: number } {

    let x = targetDeflection;

    // If length is provided, it overrides deflection input
    if (targetLength !== undefined) {
        x = freeLength - targetLength;
    }

    // Interpolate from curve
    // Find segment [i, i+1]
    // Simple clamped lookup
    if (curve.length === 0) return { x, force: 0, stress: 0, k: 0 };

    // Handle bounds
    if (x <= curve[0].x) return { x, force: curve[0].force, stress: curve[0].stress, k: curve[0].k };
    if (x >= curve[curve.length - 1].x) {
        const last = curve[curve.length - 1];
        return { x, force: last.force, stress: last.stress, k: last.k };
    }

    // Binary search or find
    const i = curve.findIndex(p => p.x >= x);
    if (i === -1) {
        const last = curve[curve.length - 1];
        return { x, force: last.force, stress: last.stress, k: last.k };
    }

    const pPrev = curve[i - 1];
    const pNext = curve[i];

    const t = (x - pPrev.x) / (pNext.x - pPrev.x);

    const force = pPrev.force + (pNext.force - pPrev.force) * t;
    const stress = pPrev.stress + (pNext.stress - pPrev.stress) * t;
    const k = pPrev.k + (pNext.k - pPrev.k) * t;

    return { x, force, stress, k };
}


// ============================================================================
// 5. Fatigue Analysis (Modified Goodman)
// ============================================================================

export function estimateFatigue(
    stressRide: number,
    stressBump: number,
    tensileStrength: number // Su
): FatigueResult {

    // 1. Calculate Mean and Alternating Shear Stress
    const tau_max = Math.max(stressRide, stressBump);
    const tau_min = Math.min(stressRide, stressBump);

    const tau_m = (tau_max + tau_min) / 2;
    const tau_a = (tau_max - tau_min) / 2;

    // 2. Material Limits Estimation
    // Assumptions:
    // Shear Ultimate Strength S_us ≈ 0.67 * S_ut (Tensile) - conservative steel
    // Often 0.577 (Von Mises) or 0.6. 
    // Standard spring wire texts use S_us ≈ 0.67 Su.
    // Torsional Yield S_ys ≈ 0.45 - 0.6 Su depending on grade.

    // Endurance Limit in Shear S_es
    // For shot-peened high quality wire: S_es ≈ 0.22 Su ?
    // Let's use Zimmerli Data approximation or standard Goodman parameters.
    // Unpeened: S_es ~ 310 MPa ? 
    // Simplified model relative to Su: S_es ≈ 0.35 Su (Optimistic) to 0.2 Su (Conservative)
    // Let's take S_us = 0.67 Su and S_es = 0.25 Su (Conservative unpeened)

    const S_us = 0.67 * tensileStrength;
    const S_es = 0.25 * tensileStrength;

    // 3. Modified Goodman Equation
    // tau_a / S_es + tau_m / S_us = 1 / SF

    const damage = (tau_a / S_es) + (tau_m / S_us);
    const safetyFactor = damage > 0 ? 1 / damage : 999;

    // 4. Utilization & Life
    const utilization = damage * 100; // %

    let lifeEstimate: FatigueResult['lifeEstimate'] = "infinite";

    if (safetyFactor < 1.0) {
        lifeEstimate = "fail";
    } else if (safetyFactor < 1.1) {
        lifeEstimate = "low_cycle";
    } else if (safetyFactor < 1.3) {
        lifeEstimate = "high_cycle";
    }

    // Re-check static yield
    // S_ys ≈ 0.56 Su
    const S_ys = 0.56 * tensileStrength;
    if (tau_max > S_ys) {
        lifeEstimate = "fail"; // Static yield failure
    }

    return {
        meanStress: tau_m,
        altStress: tau_a,
        utilization,
        safetyFactor,
        lifeEstimate,
        assumptions: [
            "Method: Modified Goodman",
            "Shear Ultimate Sus = 0.67 * Su",
            "Shear Endurance Ses = 0.25 * Su",
            "Yield Check: Tau_max < 0.56 * Su"
        ]
    };
}
