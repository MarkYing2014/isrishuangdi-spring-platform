/**
 * FEA Auto Solver Script Generator - Phase 7
 * FEA自动求解器脚本生成器
 * 
 * Generates complete Python scripts for Abaqus CAE and ANSYS APDL
 */

import type { SpringGeometry } from '../types';
import type { SpringMaterial } from '@/lib/materials/springMaterials';
import { getSpringMaterial } from '@/lib/materials/springMaterials';

/**
 * Load case definition
 */
export interface LoadCase {
  name: string;
  type: 'axial' | 'torsional' | 'combined';
  axialForce?: number;      // N
  axialDisplacement?: number; // mm
  torque?: number;          // N·mm
  rotation?: number;        // degrees
}

/**
 * Mesh settings
 */
export interface MeshSettings {
  globalSize: number;       // mm
  refinementFactor: number; // 1-5, higher = finer at curves
  elementType: 'linear' | 'quadratic';
  circumferentialDivisions: number;
}

/**
 * Material model type
 */
export type MaterialModel = 'elastic' | 'elastoplastic' | 'ramberg-osgood';

/**
 * FEA solver options
 */
export interface FEASolverOptions {
  geometry: SpringGeometry;
  loadCases: LoadCase[];
  meshSettings: MeshSettings;
  materialModel: MaterialModel;
  outputRequests: {
    stress: boolean;
    displacement: boolean;
    strain: boolean;
    fatigueLife: boolean;
    safetyFactor: boolean;
    contourImages: boolean;
  };
}

/**
 * Default mesh settings
 */
export const DEFAULT_MESH_SETTINGS: MeshSettings = {
  globalSize: 0.5,
  refinementFactor: 3,
  elementType: 'quadratic',
  circumferentialDivisions: 16,
};

/**
 * Default load cases for compression spring
 */
export function getDefaultLoadCases(geometry: SpringGeometry): LoadCase[] {
  const springRate = 10; // Approximate, will be calculated
  const maxDeflection = (geometry as any).freeLength * 0.3;
  
  return [
    {
      name: 'Preload',
      type: 'axial',
      axialDisplacement: maxDeflection * 0.3,
    },
    {
      name: 'Working_Load',
      type: 'axial',
      axialDisplacement: maxDeflection * 0.7,
    },
    {
      name: 'Max_Load',
      type: 'axial',
      axialDisplacement: maxDeflection,
    },
  ];
}

/**
 * Generate Abaqus CAE Python script
 */
export function generateAbaqusScript(options: FEASolverOptions): string {
  const { geometry, loadCases, meshSettings, materialModel, outputRequests } = options;
  const material = getSpringMaterial(geometry.materialId);
  
  const wireDiameter = geometry.wireDiameter;
  const meanDiameter = (geometry as any).meanDiameter || 
    ((geometry as any).largeOuterDiameter - wireDiameter);
  const activeCoils = geometry.activeCoils;
  const freeLength = (geometry as any).freeLength || 50;
  const pitch = (freeLength - wireDiameter * 2) / activeCoils;

  let script = `# -*- coding: utf-8 -*-
"""
Abaqus CAE Spring Analysis Script
Generated by ISRI-SHUANGDI Spring Engineering Platform
Phase 7 - Digital Twin FEA Automation

Spring Type: ${geometry.type}
Wire Diameter: ${wireDiameter} mm
Mean Diameter: ${meanDiameter} mm
Active Coils: ${activeCoils}
Material: ${material?.nameEn || geometry.materialId}
"""

from abaqus import *
from abaqusConstants import *
from caeModules import *
import math
import os

# ============================================================
# PARAMETERS
# ============================================================
WIRE_DIAMETER = ${wireDiameter}
MEAN_DIAMETER = ${meanDiameter}
ACTIVE_COILS = ${activeCoils}
TOTAL_COILS = ${activeCoils + 2}
FREE_LENGTH = ${freeLength}
PITCH = ${pitch.toFixed(4)}
HELIX_RADIUS = MEAN_DIAMETER / 2.0

# Material Properties
E_MODULUS = ${material?.elasticModulus || 207000}  # MPa
POISSON = 0.3
DENSITY = ${material?.density || 7850}e-12  # tonne/mm³ for mm units
YIELD_STRESS = ${material?.tensileStrength ? material.tensileStrength * 0.85 : 1400}  # MPa

# Mesh Settings
GLOBAL_MESH_SIZE = ${meshSettings.globalSize}
CIRC_DIVISIONS = ${meshSettings.circumferentialDivisions}

# ============================================================
# CREATE MODEL
# ============================================================
model_name = 'Spring_Analysis'
mdb.Model(name=model_name)
model = mdb.models[model_name]

# ============================================================
# CREATE GEOMETRY - Helical Spring
# ============================================================
print("Creating spring geometry...")

# Create helix path using datum points
s = model.ConstrainedSketch(name='helix_profile', sheetSize=200.0)

# Wire cross-section
s.CircleByCenterPerimeter(center=(0.0, 0.0), point1=(WIRE_DIAMETER/2, 0.0))

# Create part
part = model.Part(name='Spring', dimensionality=THREE_D, type=DEFORMABLE_BODY)

# Create helix using sweep
# First create helix curve points
helix_points = []
num_points = int(TOTAL_COILS * 36)  # 36 points per coil
for i in range(num_points + 1):
    theta = 2 * math.pi * TOTAL_COILS * i / num_points
    coil_num = theta / (2 * math.pi)
    
    # Dead coils at ends
    if coil_num < 1:
        z = coil_num * WIRE_DIAMETER
    elif coil_num > TOTAL_COILS - 1:
        z = WIRE_DIAMETER + (ACTIVE_COILS - 1) * PITCH + (coil_num - TOTAL_COILS + 1) * WIRE_DIAMETER
    else:
        z = WIRE_DIAMETER + (coil_num - 1) * PITCH
    
    x = HELIX_RADIUS * math.cos(theta)
    y = HELIX_RADIUS * math.sin(theta)
    helix_points.append((x, y, z))

# Create wire using spline
part.WireSpline(points=helix_points, mergeType=IMPRINT, smoothClosedSpline=ON)

# Sweep circular section along helix
part.SolidSweep(path=part.edges, profile=s, sketchUpEdge=part.edges[0])

# ============================================================
# MATERIAL DEFINITION
# ============================================================
print("Defining material...")

material = model.Material(name='Spring_Steel')
material.Elastic(table=((E_MODULUS, POISSON), ))
material.Density(table=((DENSITY, ), ))
`;

  // Add plasticity if needed
  if (materialModel === 'elastoplastic' || materialModel === 'ramberg-osgood') {
    script += `
# Plasticity (isotropic hardening)
material.Plastic(table=(
    (${material?.tensileStrength ? material.tensileStrength * 0.85 : 1400}, 0.0),
    (${material?.tensileStrength || 1600}, 0.05),
    (${material?.tensileStrength ? material.tensileStrength * 1.1 : 1800}, 0.10),
))
`;
  }

  if (materialModel === 'ramberg-osgood') {
    script += `
# Ramberg-Osgood parameters for cyclic analysis
# σ = E*ε + K*(ε_p)^n
K_RO = ${material?.tensileStrength ? material.tensileStrength * 1.2 : 1800}  # Strength coefficient
n_RO = 0.15  # Strain hardening exponent
`;
  }

  script += `
# ============================================================
# SECTION AND ASSIGNMENT
# ============================================================
model.HomogeneousSolidSection(name='Spring_Section', material='Spring_Steel')
part.Set(name='All_Elements', cells=part.cells)
part.SectionAssignment(region=part.sets['All_Elements'], sectionName='Spring_Section')

# ============================================================
# ASSEMBLY
# ============================================================
print("Creating assembly...")

assembly = model.rootAssembly
assembly.DatumCsysByDefault(CARTESIAN)
instance = assembly.Instance(name='Spring-1', part=part, dependent=ON)

# ============================================================
# MESH
# ============================================================
print("Meshing...")

# Seed part
part.seedPart(size=GLOBAL_MESH_SIZE, deviationFactor=0.1, minSizeFactor=0.1)

# Refine mesh at high curvature regions
edges_to_refine = part.edges.getByBoundingBox(
    xMin=-MEAN_DIAMETER, xMax=MEAN_DIAMETER,
    yMin=-MEAN_DIAMETER, yMax=MEAN_DIAMETER,
    zMin=0, zMax=WIRE_DIAMETER * 2
)
part.seedEdgeBySize(edges=edges_to_refine, size=GLOBAL_MESH_SIZE/${meshSettings.refinementFactor})

# Element type
${meshSettings.elementType === 'quadratic' ? 
  "elemType = mesh.ElemType(elemCode=C3D20R, elemLibrary=STANDARD)" :
  "elemType = mesh.ElemType(elemCode=C3D8R, elemLibrary=STANDARD)"}
part.setElementType(regions=(part.cells,), elemTypes=(elemType,))

# Generate mesh
part.generateMesh()

print(f"Mesh generated: {len(part.elements)} elements, {len(part.nodes)} nodes")

# ============================================================
# BOUNDARY CONDITIONS
# ============================================================
print("Applying boundary conditions...")

# Fixed end (bottom)
bottom_face = instance.faces.getByBoundingBox(zMax=WIRE_DIAMETER*0.5)
assembly.Set(name='Fixed_End', faces=bottom_face)
model.EncastreBC(name='Fixed_BC', createStepName='Initial', region=assembly.sets['Fixed_End'])

# Top surface for load application
top_face = instance.faces.getByBoundingBox(zMin=FREE_LENGTH - WIRE_DIAMETER*0.5)
assembly.Set(name='Load_Surface', faces=top_face)

# Reference point for load application
rp = assembly.ReferencePoint(point=(0, 0, FREE_LENGTH + 5))
assembly.Set(name='RP', referencePoints=(assembly.referencePoints[rp.id],))

# Coupling constraint
model.Coupling(name='Top_Coupling', controlPoint=assembly.sets['RP'],
               surface=assembly.sets['Load_Surface'], influenceRadius=WHOLE_SURFACE,
               couplingType=KINEMATIC, u1=ON, u2=ON, u3=ON, ur1=ON, ur2=ON, ur3=ON)

`;

  // Add load cases
  loadCases.forEach((lc, index) => {
    script += `
# ============================================================
# LOAD CASE ${index + 1}: ${lc.name}
# ============================================================
step_name = '${lc.name}'
model.StaticStep(name=step_name, previous='${ index === 0 ? 'Initial' : loadCases[index-1].name}',
                 nlgeom=ON, maxNumInc=100, initialInc=0.1, minInc=1e-8, maxInc=0.5)

`;
    if (lc.axialDisplacement !== undefined) {
      script += `model.DisplacementBC(name='Disp_${lc.name}', createStepName=step_name,
                     region=assembly.sets['RP'], u3=-${lc.axialDisplacement})
`;
    } else if (lc.axialForce !== undefined) {
      script += `model.ConcentratedForce(name='Force_${lc.name}', createStepName=step_name,
                        region=assembly.sets['RP'], cf3=-${lc.axialForce})
`;
    }
  });

  // Output requests
  script += `
# ============================================================
# OUTPUT REQUESTS
# ============================================================
`;

  if (outputRequests.stress) {
    script += `model.FieldOutputRequest(name='Stress_Output', createStepName='${loadCases[0].name}',
                         variables=('S', 'MISES', 'TRESC', 'PRESS'))
`;
  }
  if (outputRequests.displacement) {
    script += `model.FieldOutputRequest(name='Disp_Output', createStepName='${loadCases[0].name}',
                         variables=('U', 'RF'))
`;
  }
  if (outputRequests.strain) {
    script += `model.FieldOutputRequest(name='Strain_Output', createStepName='${loadCases[0].name}',
                         variables=('E', 'PE', 'PEEQ'))
`;
  }

  script += `
# ============================================================
# CREATE JOB AND SUBMIT
# ============================================================
print("Creating analysis job...")

job_name = 'Spring_Analysis_Job'
mdb.Job(name=job_name, model=model_name, type=ANALYSIS, 
        numCpus=4, numDomains=4, multiprocessingMode=DEFAULT)

# Submit job
print("Submitting job...")
mdb.jobs[job_name].submit(consistencyChecking=OFF)
mdb.jobs[job_name].waitForCompletion()

print("Analysis complete!")

# ============================================================
# POST-PROCESSING
# ============================================================
print("Post-processing results...")

from odbAccess import *
odb = openOdb(path=job_name + '.odb')

# Get last frame
last_step = odb.steps[odb.steps.keys()[-1]]
last_frame = last_step.frames[-1]

# Extract stress results
stress_field = last_frame.fieldOutputs['S']
mises_field = last_frame.fieldOutputs['MISES']

# Find maximum values
max_mises = 0
max_tresca = 0
for value in mises_field.values:
    if value.mises > max_mises:
        max_mises = value.mises

print(f"Maximum von Mises stress: {max_mises:.2f} MPa")

# Displacement
disp_field = last_frame.fieldOutputs['U']
max_disp = max([abs(v.data[2]) for v in disp_field.values])
print(f"Maximum displacement: {max_disp:.4f} mm")

# Reaction force
rf_field = last_frame.fieldOutputs['RF']
total_rf = sum([v.data[2] for v in rf_field.values if abs(v.data[2]) > 0.001])
print(f"Total reaction force: {abs(total_rf):.2f} N")

# Calculate safety factor
ALLOWABLE_STRESS = ${material?.allowShearStatic || 600}  # MPa
safety_factor = ALLOWABLE_STRESS / max_mises if max_mises > 0 else 999
print(f"Safety Factor: {safety_factor:.2f}")

`;

  if (outputRequests.contourImages) {
    script += `
# ============================================================
# GENERATE CONTOUR IMAGES
# ============================================================
print("Generating contour images...")

session.viewports['Viewport: 1'].setValues(displayedObject=odb)
session.viewports['Viewport: 1'].odbDisplay.display.setValues(plotState=(CONTOURS_ON_DEF,))

# Mises stress contour
session.viewports['Viewport: 1'].odbDisplay.setPrimaryVariable(
    variableLabel='S', outputPosition=INTEGRATION_POINT, refinement=(INVARIANT, 'Mises'))
session.printToFile(fileName='stress_mises_contour', format=PNG, canvasObjects=(session.viewports['Viewport: 1'],))

# Displacement contour
session.viewports['Viewport: 1'].odbDisplay.setPrimaryVariable(
    variableLabel='U', outputPosition=NODAL, refinement=(COMPONENT, 'U3'))
session.printToFile(fileName='displacement_contour', format=PNG, canvasObjects=(session.viewports['Viewport: 1'],))

print("Contour images saved!")
`;
  }

  if (outputRequests.fatigueLife) {
    script += `
# ============================================================
# FATIGUE LIFE ESTIMATION
# ============================================================
print("Estimating fatigue life...")

# Using Basquin equation: N = (σ_a / σ_f')^(-1/b)
sigma_f_prime = ${material?.tensileStrength ? material.tensileStrength * 1.5 : 2400}  # Fatigue strength coefficient
b = -0.085  # Fatigue strength exponent

# Alternating stress (assuming fully reversed)
sigma_a = max_mises / 2
fatigue_life = (sigma_a / sigma_f_prime) ** (1/b)
print(f"Estimated fatigue life: {fatigue_life:.2e} cycles")
`;
  }

  script += `
# ============================================================
# SAVE RESULTS
# ============================================================
results = {
    'max_mises_stress': max_mises,
    'max_displacement': max_disp,
    'reaction_force': abs(total_rf),
    'safety_factor': safety_factor,
}

import json
with open('fea_results.json', 'w') as f:
    json.dump(results, f, indent=2)

print("Results saved to fea_results.json")
print("=" * 60)
print("FEA ANALYSIS COMPLETE")
print("=" * 60)

odb.close()
`;

  return script;
}

/**
 * Generate ANSYS APDL script
 */
export function generateANSYSScript(options: FEASolverOptions): string {
  const { geometry, loadCases, meshSettings, materialModel, outputRequests } = options;
  const material = getSpringMaterial(geometry.materialId);
  
  const wireDiameter = geometry.wireDiameter;
  const meanDiameter = (geometry as any).meanDiameter || 
    ((geometry as any).largeOuterDiameter - wireDiameter);
  const activeCoils = geometry.activeCoils;
  const freeLength = (geometry as any).freeLength || 50;
  const pitch = (freeLength - wireDiameter * 2) / activeCoils;

  let script = `! ============================================================
! ANSYS APDL Spring Analysis Script
! Generated by ISRI-SHUANGDI Spring Engineering Platform
! Phase 7 - Digital Twin FEA Automation
!
! Spring Type: ${geometry.type}
! Wire Diameter: ${wireDiameter} mm
! Mean Diameter: ${meanDiameter} mm
! Active Coils: ${activeCoils}
! Material: ${material?.nameEn || geometry.materialId}
! ============================================================

FINISH
/CLEAR,START

! ============================================================
! PARAMETERS
! ============================================================
d = ${wireDiameter}                    ! Wire diameter (mm)
Dm = ${meanDiameter}                   ! Mean diameter (mm)
R = Dm/2                               ! Mean radius (mm)
Na = ${activeCoils}                    ! Active coils
Nt = ${activeCoils + 2}                ! Total coils
L0 = ${freeLength}                     ! Free length (mm)
pitch = ${pitch.toFixed(4)}            ! Pitch (mm)

! Material properties
E_mod = ${material?.elasticModulus || 207000}      ! Elastic modulus (MPa)
nu = 0.3                               ! Poisson's ratio
dens = ${material?.density || 7850}e-12            ! Density (tonne/mm³)
Sy = ${material?.tensileStrength ? material.tensileStrength * 0.85 : 1400}  ! Yield stress (MPa)

! Mesh parameters
mesh_size = ${meshSettings.globalSize}
circ_div = ${meshSettings.circumferentialDivisions}

! ============================================================
! PREPROCESSOR
! ============================================================
/PREP7

! Element type - ${meshSettings.elementType === 'quadratic' ? 'SOLID186 (20-node)' : 'SOLID185 (8-node)'}
${meshSettings.elementType === 'quadratic' ? 'ET,1,SOLID186' : 'ET,1,SOLID185'}

! Material definition
MP,EX,1,E_mod
MP,PRXY,1,nu
MP,DENS,1,dens
`;

  if (materialModel === 'elastoplastic' || materialModel === 'ramberg-osgood') {
    script += `
! Bilinear plasticity
TB,BISO,1
TBDATA,1,Sy,E_mod/100
`;
  }

  script += `
! ============================================================
! CREATE GEOMETRY - Helical Spring
! ============================================================
! Create wire cross-section
K,1,0,0,0
K,2,d/2,0,0
CIRCLE,1,d/2,,,,360
AL,ALL

! Create helix path
*DEL,helix_pts
*DIM,helix_pts,ARRAY,361,3

npts = 360
*DO,i,0,npts
    theta = 2*3.14159265*Nt*i/npts
    coil = theta/(2*3.14159265)
    
    ! Z coordinate with dead coils
    *IF,coil,LT,1,THEN
        z_coord = coil*d
    *ELSEIF,coil,GT,Nt-1
        z_coord = d + (Na-1)*pitch + (coil-Nt+1)*d
    *ELSE
        z_coord = d + (coil-1)*pitch
    *ENDIF
    
    x_coord = R*COS(theta)
    y_coord = R*SIN(theta)
    
    helix_pts(i+1,1) = x_coord
    helix_pts(i+1,2) = y_coord
    helix_pts(i+1,3) = z_coord
*ENDDO

! Create spline through helix points
*DO,i,1,npts+1
    K,100+i,helix_pts(i,1),helix_pts(i,2),helix_pts(i,3)
*ENDDO

BSPLIN,101,102,103,104,105,106
*DO,i,107,npts+101,6
    BSPLIN,i,i+1,i+2,i+3,i+4,i+5
*ENDDO

! Sweep section along helix
VDRAG,1,,,,,,ALL

! ============================================================
! MESHING
! ============================================================
! Global mesh size
ESIZE,mesh_size

! Mesh refinement at ends
ASEL,S,LOC,Z,0,d*2
AESIZE,ALL,mesh_size/${meshSettings.refinementFactor}
ASEL,ALL

! Mesh volume
VMESH,ALL

! Report mesh statistics
*GET,num_elem,ELEM,0,COUNT
*GET,num_node,NODE,0,COUNT
/COM, Mesh: %num_elem% elements, %num_node% nodes

! ============================================================
! BOUNDARY CONDITIONS
! ============================================================
! Fixed end (Z = 0)
NSEL,S,LOC,Z,0,d/2
D,ALL,ALL,0
NSEL,ALL

! Create node component for load application
NSEL,S,LOC,Z,L0-d/2,L0+d/2
CM,TOP_NODES,NODE
NSEL,ALL

! Create pilot node for load application
N,999999,0,0,L0+5
*GET,pilot_node,NODE,0,NUM,MAX

! Couple top nodes to pilot
CERIG,pilot_node,TOP_NODES,ALL

`;

  // Add load cases
  loadCases.forEach((lc, index) => {
    script += `
! ============================================================
! LOAD CASE ${index + 1}: ${lc.name}
! ============================================================
/SOLU
ANTYPE,STATIC
NLGEOM,ON
NSUBST,20,100,10
OUTRES,ALL,ALL

`;
    if (lc.axialDisplacement !== undefined) {
      script += `D,pilot_node,UZ,-${lc.axialDisplacement}
`;
    } else if (lc.axialForce !== undefined) {
      script += `F,pilot_node,FZ,-${lc.axialForce}
`;
    }

    script += `SOLVE
FINISH

`;
  });

  script += `
! ============================================================
! POST-PROCESSING
! ============================================================
/POST1

! Get last load step results
SET,LAST

! Von Mises stress
PLNSOL,S,EQV
*GET,max_mises,PLNSOL,0,MAX

! Maximum shear stress
PLNSOL,S,INT
*GET,max_tresca,PLNSOL,0,MAX

! Displacement
PLNSOL,U,SUM
*GET,max_disp,PLNSOL,0,MAX

! Reaction force at fixed end
NSEL,S,LOC,Z,0,d/2
FSUM
*GET,react_fz,FSUM,0,ITEM,FZ
NSEL,ALL

! Calculate safety factor
allow_stress = ${material?.allowShearStatic || 600}
safety_factor = allow_stress/max_mises

/COM, ============================================================
/COM, RESULTS SUMMARY
/COM, ============================================================
/COM, Maximum von Mises Stress: %max_mises% MPa
/COM, Maximum Shear Stress: %max_tresca% MPa
/COM, Maximum Displacement: %max_disp% mm
/COM, Reaction Force: %react_fz% N
/COM, Safety Factor: %safety_factor%
/COM, ============================================================

`;

  if (outputRequests.contourImages) {
    script += `
! ============================================================
! GENERATE CONTOUR IMAGES
! ============================================================
/VIEW,1,1,1,1
/ANG,1
/REP,FAST
/SHOW,PNG

! Mises stress contour
PLNSOL,S,EQV
/IMAGE,SAVE,stress_mises_contour,png

! Displacement contour
PLNSOL,U,SUM
/IMAGE,SAVE,displacement_contour,png

/SHOW,CLOSE
`;
  }

  if (outputRequests.fatigueLife) {
    script += `
! ============================================================
! FATIGUE LIFE ESTIMATION
! ============================================================
! Using Basquin equation
sigma_f = ${material?.tensileStrength ? material.tensileStrength * 1.5 : 2400}
b_exp = -0.085

sigma_a = max_mises/2
fatigue_life = (sigma_a/sigma_f)**(1/b_exp)

/COM, Estimated Fatigue Life: %fatigue_life% cycles
`;
  }

  script += `
! ============================================================
! EXPORT RESULTS
! ============================================================
/OUTPUT,fea_results,txt
*VWRITE,'max_mises_stress',max_mises
(A20,F12.2)
*VWRITE,'max_shear_stress',max_tresca
(A20,F12.2)
*VWRITE,'max_displacement',max_disp
(A20,F12.4)
*VWRITE,'reaction_force',ABS(react_fz)
(A20,F12.2)
*VWRITE,'safety_factor',safety_factor
(A20,F12.3)
/OUTPUT

/COM, Results saved to fea_results.txt
/COM, ============================================================
/COM, FEA ANALYSIS COMPLETE
/COM, ============================================================

FINISH
`;

  return script;
}

/**
 * FEA script generation result
 */
export interface FEAScriptResult {
  abaqusScript: string;
  ansysScript: string;
  filename: {
    abaqus: string;
    ansys: string;
  };
}

/**
 * Generate both FEA solver scripts
 */
export function generateFEAScripts(options: FEASolverOptions): FEAScriptResult {
  return {
    abaqusScript: generateAbaqusScript(options),
    ansysScript: generateANSYSScript(options),
    filename: {
      abaqus: `spring_analysis_${Date.now()}.py`,
      ansys: `spring_analysis_${Date.now()}.inp`,
    },
  };
}

/**
 * Download FEA script
 */
export function downloadFEAScript(
  script: string, 
  filename: string, 
  type: 'abaqus' | 'ansys'
): void {
  const mimeType = type === 'abaqus' ? 'text/x-python' : 'text/plain';
  const blob = new Blob([script], { type: mimeType });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
