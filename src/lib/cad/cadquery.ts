
import type {
    CadExportResult,
    ExtensionSpringCenterlineMm,
    TorsionSpringCenterlineMm,
    WaveSpringCenterlineMm,
    Vec3Mm
} from "@/lib/cad/types";
import type { ExtensionDesignMeta, TorsionDesignMeta } from "@/lib/stores/springSimulationStore";
import type { WaveSpringGeometry } from "@/lib/stores/springDesignStore";

type AnyCenterline = ExtensionSpringCenterlineMm | TorsionSpringCenterlineMm | WaveSpringCenterlineMm;
type AnyDesign = ExtensionDesignMeta | TorsionDesignMeta | WaveSpringGeometry;

/**
 * Generate CadQuery Python script from a Centerline
 */
export function generateCadQueryPython(
    cl: AnyCenterline,
    design: AnyDesign
): CadExportResult {

    // Decimation Strategy:
    // Hooks/Legs: Keep all points for accuracy
    // Body: Downsample if dense, but keep ends precise
    const decimate = (pts: Vec3Mm[], factor: number): Vec3Mm[] => {
        if (!pts || pts.length < 50) return pts;
        const res: Vec3Mm[] = [];
        res.push(pts[0]);
        for (let i = 1; i < pts.length - 1; i++) {
            if (i % factor === 0) res.push(pts[i]);
        }
        res.push(pts[pts.length - 1]);
        return res;
    };

    // Body can be very dense (e.g. 1200 points for 10 coils)
    // CAD kernels handle splines better with moderate density (e.g. 20-30 pts per turn)
    // Our source is 120 pts/turn -> factor 4 gives 30 pts/turn
    const bodyPts = decimate(cl.body, 4);

    const isExtension = (c: AnyCenterline): c is ExtensionSpringCenterlineMm => 'startHook' in c;
    const isTorsion = (c: AnyCenterline): c is TorsionSpringCenterlineMm => 'leg1' in c;
    const isWave = (c: AnyCenterline): c is WaveSpringCenterlineMm => 'widthMm' in c.stats;

    // Determine Profile
    let profile: { type: "circle", radius: number } | { type: "rect", width: number, thickness: number };

    if (isWave(cl)) {
        profile = {
            type: "rect",
            width: cl.stats.widthMm,
            thickness: cl.stats.thicknessMm
        };
    } else if (isExtension(cl) || isTorsion(cl)) {
        profile = {
            type: "circle",
            radius: cl.stats.wireDiameterMm / 2.0
        };
    } else {
        // Fallback
        profile = { type: "circle", radius: 0.5 };
    }

    let payload: any = {
        meta: cl.stats,
        body: bodyPts,
        profile: profile
    };

    if (isExtension(cl)) {
        payload.startHook = cl.startHook;
        payload.endHook = cl.endHook;
    } else if (isTorsion(cl)) {
        payload.leg1 = cl.leg1;
        payload.leg2 = cl.leg2;
    }

    const jsonData = JSON.stringify(payload, null, 2);

    // Python script template
    let partName = "Spring";
    if (isWave(cl)) partName = "WaveSpring";
    else if (isTorsion(cl)) partName = "TorsionSpring";
    else if (isExtension(cl)) partName = "ExtensionSpring";

    // Construct Meta Comments
    let metaComments = `# Type: ${design.type} \n`;
    if (isWave(cl)) {
        metaComments += `# Thickness: ${cl.stats.thicknessMm} mm
# Width: ${cl.stats.widthMm} mm
# Mean Radius: ${cl.stats.meanRadiusMm} mm
# Active Coils: ${cl.stats.activeCoils}
# Waves Per Turn: ${cl.stats.wavesPerTurn}
# Amplitude: ${cl.stats.amplitudeMm} mm`;
    } else if (isExtension(cl)) {
        metaComments += `# Wire Dia: ${cl.stats.wireDiameterMm} mm
# Mean Radius: ${cl.stats.meanRadiusMm} mm
# Active Coils: ${cl.stats.activeCoils}
# Hook Type: ${cl.stats.hookType} `;
    } else if (isTorsion(cl)) {
        metaComments += `# Wire Dia: ${cl.stats.wireDiameterMm} mm
# Mean Radius: ${cl.stats.meanRadiusMm} mm
# Active Coils: ${cl.stats.activeCoils}
# Body Length: ${cl.stats.bodyLengthMm} mm`;
    }

    const pythonScript = `import cadquery as cq
import json
import math

# ==============================================================================
# Spring Generation Script(CadQuery)
# Generated by Spring Platform
# Date: ${new Date().toISOString()}
# Unit: mm
#
# Parameters:
${metaComments}
# ==============================================================================

# Embedded Centerline Data
data = json.loads('''${jsonData}''')

def create_spline_wire(points_list):
if not points_list or len(points_list) < 2:
return None
    # Convert dicts to tuples for CadQuery
    vecs = [(p['x'], p['y'], p['z']) for p in points_list]
return cq.Wire.makeSpline(vecs)

def build_solid():
profile_data = data.get('profile', { 'type': 'circle', 'radius': 1.0 })

    # 1. Build Centerline Wires
wires = []

    # Extension Spring Parts
if data.get('startHook'):
    w = create_spline_wire(data['startHook'])
if w: wires.append(w)

    # Torsion Spring Legs
if data.get('leg1'):
    w = create_spline_wire(data['leg1'])
if w: wires.append(w)

    # Body(Common)
if data.get('body'):
    w = create_spline_wire(data['body'])
if w: wires.append(w)

    # Extension Spring Parts
if data.get('endHook'):
    w = create_spline_wire(data['endHook'])
if w: wires.append(w)

    # Torsion Spring Legs
if data.get('leg2'):
    w = create_spline_wire(data['leg2'])
if w: wires.append(w)

if not wires:
    print("Error: No valid wires generated")
return None

    # 2. Assemble into single path
try:
        # Assemble edges into a single wire
edges = []
for w in wires:
    edges.extend(w.Edges())

centerline = cq.Wire.assembleEdges(edges)
    except Exception as e:
print(f"Assembly Error: {e}")
return None

    # 3. Sweep
try:
        # Create profile at ORIGIN of the Workplane, it will be moved to start of path
        # But for 'sweep', usually we rely on newObject OR explicit profile

        # Method A: Using newObject([centerline]) creates a Workplane masked by the wire
        # But standard CQ usage for sweep is:
        # cq.Workplane("XY").newObject([centerline]).circle(r).sweep(centerline, ...)
        # Actually.circle() creates a circle on the current plane(XY).

        # For Rectangular Wave Spring(Profile XZ):
        # We need Width(Radial) along X, Thickness(Axial) along Z ?
        # If we use Workplane("XY"), Z is normal.
        # This matches Axial ?
        # NO.If we sketch on XY, and sweep along a path that starts at $(R, 0, 0)$ and goes towards Y.
        # The profile is transformed to the start.
        # Reference: CadQuery docs.
        # "Profiles are defined on the XY plane. During the sweep, the XY plane is mapped to the plan defined by the path tangent and normal."

wp = cq.Workplane("XY").newObject([centerline])

if profile_data['type'] == 'rect':
    w = profile_data['width']      # Radial
t = profile_data['thickness']  # Axial
            # Rect on XY.X maps to Radial ? Y maps to Tangent ? Z maps to Axial ?
            # Actually, standard sweep maps XY plane key directions to Normal / Binormal of path.
            # Usually: X -> Normal(Radial), Y -> Binormal(Axial).Z -> Tangent.
            # No, Z is normal to the profile plane, so Z -> Tangent.
            # So X / Y of profile sketch map to Normal / Binormal.
            # We want Width -> Radial(Normal).Thickness -> Axial(Binormal).
            # So.rect(width, thickness) on XY plane should work!
solid = wp.rect(w, t).sweep(centerline, isFrenet = True, transition = 'round')

        else:
r = profile_data['radius']
solid = wp.circle(r).sweep(centerline, isFrenet = True, transition = 'round')

return solid
    except Exception as e:
print(f"Sweep Error: {e}")
return None

# ==============================================================================
# Main Execution
# ==============================================================================

    solid = build_solid()

if solid:
    filename = "${partName}.step".lower()
cq.exporters.export(solid, filename)
print(f"Successfully exported {filename}")
else:
print("Failed to generate solid")
`;

    return {
        ok: true,
        kernel: "cadquery",
        filename: `${partName}_${Date.now()}.py`,
        content: pythonScript,
        meta: {
            partName: partName,
            unit: "mm",
            generatedAtIso: new Date().toISOString(),
        }
    };
}
