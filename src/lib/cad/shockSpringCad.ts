/**
 * Shock Absorber Spring CAD Exporter
 * 减震器弹簧 FreeCAD 导出
 * 
 * Generates a standalone Python script for FreeCAD that:
 * - Re-implements the SAME law functions as TypeScript
 * - Uses the SAME sampling and numerical integration
 * - Computes PTF frames in Python
 * - Creates solid using lofted sections (not pipe shell)
 * - Applies boolean cuts for grinding
 * 
 * This ensures Three.js and FreeCAD produce matching geometry.
 */

import type { ShockSpringParams } from '../spring3d/shock/types';

/**
 * Generate a FreeCAD Python script for the shock absorber spring
 * 
 * @param params Spring parameters
 * @returns Python script as a string
 */
export function generateShockSpringFreeCADScript(params: ShockSpringParams): string {
    const paramsJson = JSON.stringify(params, null, 2);

    const script = `# ============================================================
# Shock Absorber Spring – FreeCAD Generator
# 减震器弹簧 – FreeCAD 生成脚本
# 
# Generated by Spring Platform
# Date: ${new Date().toISOString()}
# 
# This script implements the SAME law functions and numerical
# integration as the TypeScript frontend to ensure matching geometry.
# 
# End grinding is defined by TURNS, not by height.
# ============================================================

import FreeCAD as App
import Part
import math
from FreeCAD import Vector

# ============================================================
# Embedded Parameters
# ============================================================

params = ${paramsJson}

# ============================================================
# Helper Functions
# ============================================================

def smoothstep(edge0, edge1, x):
    """Smoothstep interpolation (C1 continuous)"""
    if edge1 <= edge0:
        return 1.0 if x >= edge0 else 0.0
    t = max(0.0, min(1.0, (x - edge0) / (edge1 - edge0)))
    return t * t * (3.0 - 2.0 * t)

def lerp(a, b, t):
    """Linear interpolation"""
    return a + (b - a) * t

def clamp(value, min_val, max_val):
    """Clamp value between min and max"""
    return max(min_val, min(max_val, value))

# ============================================================
# Law Functions (MUST MATCH TypeScript exactly)
# ============================================================

def mean_radius_law(s):
    """
    Mean radius law: R(s) for s in [0, 1]
    Shapes: bulge, hourglass, linear
    """
    mean_dia = params['meanDia']
    start = mean_dia['start']
    mid = mean_dia['mid']
    end = mean_dia['end']
    shape = mean_dia['shape']
    
    # Convert diameters to radii
    r_start = start / 2.0
    r_mid = mid / 2.0
    r_end = end / 2.0
    
    if shape == 'bulge':
        # Bulge: ends small, middle large
        blend = math.sin(math.pi * s)
        end_blend = r_start + (r_end - r_start) * s
        return end_blend + (r_mid - end_blend) * blend
    
    elif shape == 'hourglass':
        # Hourglass: ends large, middle small
        blend = math.sin(math.pi * s)
        end_blend = r_start + (r_end - r_start) * s
        return end_blend - (end_blend - r_mid) * blend
    
    elif shape == 'linear':
        # Piecewise linear with smooth transition
        transition_width = 0.15
        
        if s < 0.5 - transition_width:
            return r_start + (r_mid - r_start) * (s / 0.5)
        elif s > 0.5 + transition_width:
            t = (s - 0.5) / 0.5
            return r_mid + (r_end - r_mid) * t
        else:
            before_mid = r_start + (r_mid - r_start) * (s / 0.5)
            after_mid = r_mid + (r_end - r_mid) * ((s - 0.5) / 0.5)
            blend = smoothstep(0.5 - transition_width, 0.5 + transition_width, s)
            return lerp(before_mid, after_mid, blend)
    
    return r_start

def wire_diameter_law(s):
    """
    Wire diameter law: d(s) for s in [0, 1]
    Uses sin(pi*s) blend for C1 continuity
    """
    wire_dia = params['wireDia']
    start = wire_dia['start']
    mid = wire_dia['mid']
    end = wire_dia['end']
    
    blend = math.sin(math.pi * s)
    end_blend = start + (end - start) * s
    return end_blend + (mid - end_blend) * blend

def pitch_law(s):
    """
    Pitch law: P(s) for s in [0, 1]
    Closed zones at ends, working zone in middle
    """
    pitch = params['pitch']
    total_turns = params['totalTurns']
    wire_dia = params['wireDia']
    
    closed_turns = pitch['closedTurns']
    working_min = pitch['workingMin']
    working_max = pitch['workingMax']
    transition_sharpness = pitch['transitionSharpness']
    closed_pitch_factor = pitch.get('closedPitchFactor', 1.0)
    
    # Closed zone fraction
    closed_frac = closed_turns / total_turns
    
    # Closed pitch at each end
    closed_pitch_start = closed_pitch_factor * wire_dia['start']
    closed_pitch_end = closed_pitch_factor * wire_dia['end']
    
    # Working weight (0 at ends, 1 in middle)
    left_weight = smoothstep(0, closed_frac, s)
    right_weight = smoothstep(1, 1 - closed_frac, s)
    working_weight = min(left_weight, right_weight)
    
    # Working zone pitch
    sin_blend = pow(math.sin(math.pi * s), clamp(transition_sharpness, 0.1, 2.0))
    working_pitch = working_min + (working_max - working_min) * sin_blend
    
    # Closed pitch (blend based on position)
    closed_pitch = lerp(closed_pitch_start, closed_pitch_end, s)
    
    # Final pitch
    return lerp(closed_pitch, working_pitch, working_weight)

# ============================================================
# Centerline Generation
# ============================================================

def build_centerline():
    """
    Build centerline using same algorithm as TypeScript:
    - Numerical integration of pitch using trapezoidal rule
    - Returns points, radii, s_values
    """
    total_turns = params['totalTurns']
    samples_per_turn = params['samplesPerTurn']
    
    total_samples = max(2, int(total_turns * samples_per_turn) + 1)
    
    points = []
    radii = []
    s_values = []
    z_values = [0.0]
    
    for i in range(total_samples):
        s = i / (total_samples - 1)
        s_values.append(s)
        
        theta = 2.0 * math.pi * total_turns * s
        R = mean_radius_law(s)
        
        x = R * math.cos(theta)
        y = R * math.sin(theta)
        
        # Z from numerical integration (trapezoidal rule)
        if i > 0:
            s0 = s_values[i - 1]
            s1 = s
            P0 = pitch_law(s0)
            P1 = pitch_law(s1)
            dz = total_turns * 0.5 * (P0 + P1) * (s1 - s0)
            z_values.append(z_values[i - 1] + dz)
        
        points.append(Vector(x, y, z_values[i]))
        radii.append(0.5 * wire_diameter_law(s))
    
    return points, radii, s_values

# ============================================================
# Parallel Transport Frames (PTF)
# ============================================================

def normalize(v):
    """Normalize a vector"""
    length = v.Length
    if length < 1e-10:
        return Vector(0, 0, 1)
    return v * (1.0 / length)

def find_perpendicular(v):
    """Find a perpendicular vector"""
    refs = [Vector(1, 0, 0), Vector(0, 1, 0), Vector(0, 0, 1)]
    best_ref = refs[0]
    min_dot = abs(v.dot(refs[0]))
    
    for ref in refs[1:]:
        dot = abs(v.dot(ref))
        if dot < min_dot:
            min_dot = dot
            best_ref = ref
    
    return normalize(v.cross(best_ref))

def compute_ptf_frames(points):
    """
    Compute Parallel Transport Frames
    Returns tangents, normals, binormals
    """
    n = len(points)
    
    if n < 2:
        return [Vector(0, 0, 1)], [Vector(1, 0, 0)], [Vector(0, 1, 0)]
    
    tangents = []
    normals = []
    binormals = []
    
    # Compute tangents
    for i in range(n):
        if i == 0:
            t = points[1] - points[0]
        elif i == n - 1:
            t = points[n - 1] - points[n - 2]
        else:
            t = points[i + 1] - points[i - 1]
        tangents.append(normalize(t))
    
    # Initial normal
    ref = Vector(0, 1, 0)
    if abs(tangents[0].dot(ref)) > 0.9:
        ref = Vector(1, 0, 0)
    
    initial = ref - tangents[0] * tangents[0].dot(ref)
    if initial.Length > 1e-10:
        normals.append(normalize(initial))
    else:
        normals.append(find_perpendicular(tangents[0]))
    
    binormals.append(normalize(tangents[0].cross(normals[0])))
    
    # Propagate frames
    for i in range(1, n):
        prev_t = tangents[i - 1]
        curr_t = tangents[i]
        prev_n = normals[i - 1]
        
        axis = prev_t.cross(curr_t)
        
        if axis.Length < 1e-10:
            new_normal = prev_n
        else:
            axis = normalize(axis)
            dot = max(-1.0, min(1.0, prev_t.dot(curr_t)))
            angle = math.acos(dot)
            
            if dot < -0.999:
                axis = find_perpendicular(prev_t)
            
            # Rotate using Rodrigues' formula
            new_normal = (
                prev_n * math.cos(angle) +
                axis.cross(prev_n) * math.sin(angle) +
                axis * axis.dot(prev_n) * (1 - math.cos(angle))
            )
        
        new_binormal = curr_t.cross(new_normal)
        if new_binormal.Length < 1e-10:
            new_binormal = binormals[i - 1]
        else:
            new_binormal = normalize(new_binormal)
        
        new_normal = normalize(new_binormal.cross(curr_t))
        
        normals.append(new_normal)
        binormals.append(new_binormal)
    
    return tangents, normals, binormals

# ============================================================
# Solid Generation (Lofted Sections)
# ============================================================

def make_solid(points, radii, tangents, normals, binormals):
    """
    Create solid using lofted sections (NOT pipe shell)
    This matches PTF frames exactly
    """
    circle_segments = 24
    wires = []
    
    for i, (pt, r) in enumerate(zip(points, radii)):
        n = normals[i]
        b = binormals[i]
        
        # Create circle vertices
        circle_pts = []
        for j in range(circle_segments + 1):
            angle = (j / circle_segments) * 2.0 * math.pi
            cos_a = math.cos(angle)
            sin_a = math.sin(angle)
            
            vertex = pt + n * cos_a * r + b * sin_a * r
            circle_pts.append(vertex)
        
        # Create wire
        wire = Part.makePolygon(circle_pts)
        wires.append(wire)
    
    # Loft all sections
    try:
        solid = Part.makeLoft(wires, True)
        return solid
    except Exception as e:
        print(f"Loft failed: {e}")
        return None

# ============================================================
# End Grinding (Boolean Cuts)
# ============================================================

def find_closest_s_index(s_values, target_s):
    """Find index of closest s value"""
    min_dist = float('inf')
    best_idx = 0
    
    for i, s in enumerate(s_values):
        dist = abs(s - target_s)
        if dist < min_dist:
            min_dist = dist
            best_idx = i
    
    return best_idx

def compute_grind_cut_planes(points, s_values):
    """
    Compute z-coordinates for grinding cut planes based on TURNS
    """
    grind = params['grind']
    total_turns = params['totalTurns']
    offset_turns = grind['offsetTurns']
    
    s_cut = offset_turns / total_turns
    
    z_cut_bottom = None
    z_cut_top = None
    
    if grind['bottom'] and s_cut > 0 and s_cut < 1:
        idx = find_closest_s_index(s_values, s_cut)
        z_cut_bottom = points[idx].z
    
    if grind['top'] and s_cut > 0 and s_cut < 1:
        idx = find_closest_s_index(s_values, 1.0 - s_cut)
        z_cut_top = points[idx].z
    
    return z_cut_bottom, z_cut_top

def apply_grinding(solid, z_cut_bottom, z_cut_top):
    """
    Apply boolean cuts for grinding
    """
    if solid is None:
        return None
    
    bbox = solid.BoundBox
    cut_height = 100.0
    cut_size = max(bbox.XLength, bbox.YLength) * 2.0
    
    if z_cut_bottom is not None:
        # Cut everything below z_cut_bottom
        cutter = Part.makeBox(
            cut_size, cut_size, cut_height,
            Vector(-cut_size/2, -cut_size/2, z_cut_bottom - cut_height)
        )
        try:
            solid = solid.cut(cutter)
        except Exception as e:
            print(f"Bottom cut failed: {e}")
    
    if z_cut_top is not None:
        # Cut everything above z_cut_top
        cutter = Part.makeBox(
            cut_size, cut_size, cut_height,
            Vector(-cut_size/2, -cut_size/2, z_cut_top)
        )
        try:
            solid = solid.cut(cutter)
        except Exception as e:
            print(f"Top cut failed: {e}")
    
    return solid

# ============================================================
# Debug Output
# ============================================================

def debug_print(points, radii, s_values):
    """Print debug information"""
    print("=" * 60)
    print("Shock Absorber Spring - Debug Info")
    print("=" * 60)
    print(f"Total samples: {len(points)}")
    print(f"Total height: {points[-1].z - points[0].z:.3f} mm")
    print(f"Total turns: {params['totalTurns']}")
    print(f"Closed turns: {params['pitch']['closedTurns']}")
    print(f"Closed fraction: {params['pitch']['closedTurns'] / params['totalTurns']:.4f}")
    print(f"Grinding offset: {params['grind']['offsetTurns']} turns")
    
    # Pitch range
    pitch_values = [pitch_law(s) for s in s_values]
    print(f"Pitch range: {min(pitch_values):.3f} ~ {max(pitch_values):.3f} mm")
    
    # Wire radius range
    print(f"Wire radius range: {min(radii):.3f} ~ {max(radii):.3f} mm")
    
    # Grind cut planes
    z_bottom, z_top = compute_grind_cut_planes(points, s_values)
    if z_bottom is not None:
        print(f"Bottom cut z: {z_bottom:.3f} mm")
    if z_top is not None:
        print(f"Top cut z: {z_top:.3f} mm")
    
    print(f"First 3 points: {[(p.x, p.y, p.z) for p in points[:3]]}")
    print(f"Last 3 points: {[(p.x, p.y, p.z) for p in points[-3:]]}")
    print("=" * 60)

# ============================================================
# Main Function
# ============================================================

def make_shock_spring(doc=None):
    """
    Create the shock absorber spring
    Returns the solid shape
    """
    # Build centerline
    points, radii, s_values = build_centerline()
    
    # Debug output
    debug_print(points, radii, s_values)
    
    # Compute PTF frames
    tangents, normals, binormals = compute_ptf_frames(points)
    
    # Add centerline to doc if exists
    if doc is not None:
        try:
            wire = Part.makePolygon(points)
            obj = doc.addObject("Part::Feature", "ShockSpring_Centerline")
            obj.Shape = wire
            obj.ViewObject.LineColor = (1.0, 0.0, 0.0)
        except Exception as e:
            print(f"Failed to add centerline: {e}")
    
    # Create solid
    solid = make_solid(points, radii, tangents, normals, binormals)
    
    if solid is None:
        print("Failed to create solid")
        return None
    
    # Apply grinding
    z_bottom, z_top = compute_grind_cut_planes(points, s_values)
    solid = apply_grinding(solid, z_bottom, z_top)
    
    return solid

def main():
    """Main entry point"""
    # Create new document
    doc = App.newDocument("ShockSpring")
    
    # Create spring
    solid = make_shock_spring(doc)
    
    if solid is not None:
        obj = doc.addObject("Part::Feature", "ShockSpring")
        obj.Shape = solid
        obj.ViewObject.ShapeColor = (0.29, 0.56, 0.85)  # #4a90d9
    
    # Recompute
    doc.recompute()
    
    # Fit view
    try:
        import FreeCADGui
        FreeCADGui.ActiveDocument.ActiveView.fitAll()
    except:
        pass
    
    print("Done! Shock absorber spring created.")

# Run if executed directly
if __name__ == "__main__":
    main()
`;

    return script;
}
